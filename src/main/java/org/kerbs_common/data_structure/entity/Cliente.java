package org.kerbs_common.data_structure.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Abstract base class for all client types in the Kerbs system.
 * 
 * Simplified architecture where Empresa and ClienteFinal differ only in pricing strategy:
 * - Empresa: Uses custom pricing (managed by Admin microservice)
 * - ClienteFinal: Always uses STANDARD pricing (can be created by Operations)
 * 
 * Uses JOINED inheritance strategy where the base class has its own table
 * and subclasses join to it with their specific fields.
 * 
 * Design decisions:
 * - JOINED: Base table 'cliente' with subclass tables 'empresa' and 'cliente_final'
 * - Long id as autogenerated primary key for performance
 * - razonSocial is the display name used throughout the application
 */
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Table(name = "cliente")
@Getter
@Setter
public abstract class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "cliente_id")
    private Long id;

    @Column(name = "pricing_plan", nullable = false, length = 50)
    private String pricingPlan; // Business key for pricing: "STANDARD", "MASTELLONE", etc.

    @Column(name = "razon_social", nullable = false, length = 255)
    private String razonSocial; // Main display name for frontend

    @Column(name = "nombre", length = 255)
    private String nombre;

    @Column(name = "apellido", length = 255)
    private String apellido;

    @Column(name = "cuit", length = 20)
    private String cuit;

    @Column(name = "condicion_iva", length = 50)
    private String condicionIva;

    @Column(name = "direccion", length = 500)
    private String direccion;

    @Column(name = "telefono", length = 50)
    private String telefono;

    @Column(name = "email", length = 255)
    private String email;

    @CreationTimestamp
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;

    @UpdateTimestamp
    @Column(name = "fecha_actualizacion")
    private LocalDateTime fechaActualizacion;

    // Bidirectional relationship with Heladera
    @OneToMany(mappedBy = "cliente", fetch = FetchType.LAZY)
    private List<Heladera> heladeras;

    // Constructors
    protected Cliente() {}

    public Cliente(String pricingPlan, String razonSocial) {
        this.pricingPlan = pricingPlan;
        this.razonSocial = razonSocial;
    }

    public Cliente(String pricingPlan, String razonSocial, String nombre, String apellido) {
        this.pricingPlan = pricingPlan;
        this.razonSocial = razonSocial;
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public Cliente(String pricingPlan, String razonSocial, String nombre, String apellido, String cuit, 
                   String condicionIva, String direccion, String telefono, String email) {
        this.pricingPlan = pricingPlan;
        this.razonSocial = razonSocial;
        this.nombre = nombre;
        this.apellido = apellido;
        this.cuit = cuit;
        this.condicionIva = condicionIva;
        this.direccion = direccion;
        this.telefono = telefono;
        this.email = email;
    }

    // Business methods
    public String getNombreCompleto() {
        if (nombre != null && apellido != null) {
            return nombre + " " + apellido;
        } else if (nombre != null) {
            return nombre;
        }
        return razonSocial; // Fallback to razonSocial
    }

    // Abstract method to differentiate pricing strategy
    public abstract boolean usaPreciosPersonalizados();

    // toString for debugging
    @Override
    public String toString() {
        return getClass().getSimpleName() + "{" +
                "id=" + id +
                ", pricingPlan='" + pricingPlan + '\'' +
                ", razonSocial='" + razonSocial + '\'' +
                '}';
    }

    // equals and hashCode based on id (primary key)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        return id != null && id.equals(cliente.id);
    }

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }
}